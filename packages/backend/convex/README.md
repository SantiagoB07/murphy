# Convex Backend Architecture

This document describes the patterns and conventions used in our Convex backend.

## Directory Structure

```
convex/
├── _generated/           # Auto-generated by Convex (do not edit)
├── agent/                # AI agent HTTP endpoints (ElevenLabs integration)
│   ├── types.ts          # Shared types for agent module
│   ├── helpers.ts        # HTTP response helpers
│   ├── queries.ts        # Internal queries for agent tools
│   ├── mutations.ts      # Internal mutations for agent tools
│   ├── actions.ts        # External API calls (ElevenLabs)
│   └── http*.ts          # HTTP action handlers by domain
├── lib/                  # Shared utilities
│   ├── auth.ts           # Authentication helpers
│   └── validators.ts     # Shared validators and type utilities
├── model/                # Business logic layer (pure functions)
│   ├── patients.ts       # Patient profile helpers
│   ├── glucoseRecords.ts # Glucose record helpers
│   ├── insulinRecords.ts # Insulin dose and schedule helpers
│   ├── wellnessRecords.ts# Sleep, stress, dizziness helpers
│   ├── treatmentSlots.ts # Treatment slot helpers
│   └── notifications.ts  # Notification preference helpers
├── schema.ts             # Database schema definition
├── http.ts               # HTTP router (registers all HTTP endpoints)
└── *.ts                  # API files (thin wrappers exposing model functions)
```

## Architecture Pattern: Model Layer

We follow the **Model Layer pattern** from Convex best practices. This separates:

1. **Model Layer** (`model/*.ts`) - Pure TypeScript functions containing business logic
2. **API Layer** (root `*.ts` files) - Thin Convex functions that handle auth and delegate to model

### Why This Pattern?

- **Testability**: Model functions are pure and can be unit tested
- **Reusability**: Same logic can be called from queries, mutations, and internal functions
- **Separation of concerns**: Auth/validation in API layer, business logic in model layer
- **Type safety**: Model functions have explicit input/output types

## Model Layer (`model/*.ts`)

Model files export pure async functions that take `ctx` and typed arguments:

```ts
// model/glucoseRecords.ts
import { QueryCtx, MutationCtx } from "../_generated/server";
import { Id, Doc } from "../_generated/dataModel";

export async function loadById(
  ctx: QueryCtx | MutationCtx,
  args: { id: Id<"glucoseRecords">; patientId: Id<"patientProfiles"> }
): Promise<Doc<"glucoseRecords">> {
  const record = await ctx.db.get(args.id);
  if (!record || record.patientId !== args.patientId) {
    throw new Error("Record not found");
  }
  return record;
}

export async function createRecord(
  ctx: MutationCtx,
  args: {
    patientId: Id<"patientProfiles">;
    value: number;
    date: string;
    notes?: string;
  }
): Promise<{ id: Id<"glucoseRecords"> }> {
  const id = await ctx.db.insert("glucoseRecords", {
    patientId: args.patientId,
    value: args.value,
    date: args.date,
    recordedAt: Date.now(),
    notes: args.notes,
  });
  return { id };
}
```

### Naming Conventions

| Function Type | Naming Pattern | Example |
|--------------|----------------|---------|
| Load single record | `loadById`, `loadByIdOrNull` | `Patients.loadById(ctx, id)` |
| Load by other field | `loadByClerkUserId` | `Patients.loadByClerkUserId(ctx, clerkId)` |
| Get latest record | `getLatestByPatient`, `getLatest*` | `GlucoseRecords.getLatestByPatient(ctx, patientId)` |
| List records | `listByPatient`, `listByDate` | `GlucoseRecords.listByPatient(ctx, { patientId, limit })` |
| Create record | `createRecord`, `create*` | `GlucoseRecords.createRecord(ctx, { ... })` |
| Update record | `updateRecord`, `updateRecordInternal` | `GlucoseRecords.updateRecord(ctx, { id, ... })` |
| Delete record | `deleteRecord` | `GlucoseRecords.deleteRecord(ctx, { id, patientId })` |
| Upsert record | `upsert*` | `WellnessRecords.upsertSleepRecord(ctx, { ... })` |
| Get aggregates | `getStats`, `getContext` | `GlucoseRecords.getStats(ctx, { startDate, endDate })` |

### Internal vs Authorized Functions

Some model functions have two variants:

- `updateRecord` - Validates ownership (patientId must match)
- `updateRecordInternal` - No ownership check (for internal/agent use)

```ts
// With ownership check (for API layer)
export async function updateRecord(ctx, args: { id, patientId, ...updates }) {
  const record = await ctx.db.get(args.id);
  if (!record || record.patientId !== args.patientId) {
    throw new Error("Record not found");
  }
  await ctx.db.patch(args.id, updates);
}

// Without ownership check (for internal mutations)
export async function updateRecordInternal(ctx, args: { id, ...updates }) {
  await ctx.db.patch(args.id, updates);
}
```

## API Layer (Root `*.ts` Files)

API files are thin wrappers that:
1. Authenticate the user
2. Validate arguments (via Convex validators)
3. Delegate to model functions

```ts
// glucoseRecords.ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { getCurrentPatient } from "./lib/auth";
import * as GlucoseRecords from "./model/glucoseRecords";

export const list = query({
  args: {
    startDate: v.optional(v.string()),
    endDate: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const patient = await getCurrentPatient(ctx);
    return GlucoseRecords.listByPatient(ctx, {
      patientId: patient._id,
      ...args,
    });
  },
});

export const create = mutation({
  args: {
    value: v.number(),
    date: v.string(),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const patient = await getCurrentPatient(ctx);
    return GlucoseRecords.createRecord(ctx, {
      patientId: patient._id,
      ...args,
    });
  },
});
```

### API Naming Conventions

| Operation | Function Name | HTTP Equivalent |
|-----------|--------------|-----------------|
| List records | `list` | GET /records |
| Get single | `getById`, `getByDate` | GET /records/:id |
| Create | `create` | POST /records |
| Update | `update` | PATCH /records/:id |
| Delete | `remove` | DELETE /records/:id |
| Toggle state | `toggle` | PATCH /records/:id/toggle |

## Shared Utilities (`lib/`)

### `lib/auth.ts` - Authentication

```ts
import { getCurrentPatient } from "./lib/auth";

// In a query/mutation handler:
const patient = await getCurrentPatient(ctx);
// Returns: { _id: Id<"patientProfiles">, clerkUserId: string }
// Throws if not authenticated or profile not found

// For optional auth:
const patient = await getCurrentPatientOrNull(ctx);
// Returns null instead of throwing
```

### `lib/validators.ts` - Shared Validators

Convex validators for reuse across files:

```ts
import { diabetesTypes, insulinTypes, genderTypes } from "./lib/validators";

// In schema or function args:
args: {
  diabetesType: diabetesTypes,  // v.union(v.literal("Tipo 1"), ...)
  insulinType: insulinTypes,    // v.union(v.literal("rapid"), v.literal("basal"))
}
```

TypeScript types (inferred from validators):

```ts
import { DiabetesType, InsulinType, GenderType } from "./lib/validators";
```

Utility functions:

```ts
import { 
  getTodayDate,        // Returns "YYYY-MM-DD"
  getCurrentTime,      // Returns "HH:MM"
  getDateRange,        // Returns { startOfDay, endOfDay } timestamps
  formatRelativeTime,  // Returns "hace 5 min", "ayer", etc.
  isValidInsulinType,  // Type guard
} from "./lib/validators";
```

## Agent Module (`agent/`)

The `agent/` folder contains HTTP endpoints for the ElevenLabs voice AI integration.

### Structure

```
agent/
├── types.ts       # AgentResponse, RequestBody, InitiateCallResult
├── helpers.ts     # jsonResponse(), errorResponse(), successResponse(), parseBody()
├── queries.ts     # internalQuery wrappers for reading data
├── mutations.ts   # internalMutation wrappers for writing data
├── actions.ts     # internalAction for external API calls (ElevenLabs)
└── http*.ts       # httpAction handlers by domain
```

### HTTP Actions Pattern

HTTP actions receive raw requests and must:
1. Parse and validate the request body
2. Run internal queries/mutations to access the database
3. Return a Response object

```ts
// agent/httpGlucometry.ts
import { httpAction } from "../_generated/server";
import { internal } from "../_generated/api";
import { parseBody, errorResponse, successResponse } from "./helpers";
import { isValidPatientId } from "./types";

export const httpSaveGlucometry = httpAction(async (ctx, request) => {
  const body = await parseBody(request);
  if (!body) {
    return errorResponse("Invalid JSON body");
  }

  const patientId = body.patient_id ?? body.glucometry_data?.patient_id;
  const value = body.value ?? body.glucometry_data?.value;

  if (!isValidPatientId(patientId) || value === undefined) {
    return errorResponse("patient_id y value son requeridos");
  }

  // Validate patient exists
  const patient = await ctx.runQuery(internal.agent.queries.getPatientById, {
    patientId: patientId as Id<"patientProfiles">,
  });

  if (!patient) {
    return errorResponse("Paciente no encontrado", 404);
  }

  await ctx.runMutation(internal.agent.mutations.saveGlucoseRecord, {
    patientId: patientId as Id<"patientProfiles">,
    value: Number(value),
  });

  return successResponse(`Glucosa de ${value} mg/dL registrada correctamente`);
});
```

### Internal Functions for HTTP Actions

HTTP actions cannot access `ctx.db` directly. They must use `ctx.runQuery()` and `ctx.runMutation()` with internal functions:

```ts
// agent/queries.ts
export const getPatientById = internalQuery({
  args: { patientId: v.id("patientProfiles") },
  handler: async (ctx, args) => {
    return Patients.loadByIdOrNull(ctx, args.patientId);
  },
});

// agent/mutations.ts
export const saveGlucoseRecord = internalMutation({
  args: {
    patientId: v.id("patientProfiles"),
    value: v.number(),
  },
  handler: async (ctx, args) => {
    await GlucoseRecords.createRecord(ctx, { ... });
    return { success: true };
  },
});
```

### Registering HTTP Routes

All HTTP routes are registered in `http.ts`:

```ts
// http.ts
import { httpRouter } from "convex/server";
import { httpSaveGlucometry, httpUpdateGlucometry } from "./agent/httpGlucometry";

const http = httpRouter();

http.route({
  path: "/api/agent/save-glucometry",
  method: "POST",
  handler: httpSaveGlucometry,
});

export default http;
```

## Function Types Reference

| Type | Import | Use Case |
|------|--------|----------|
| `query` | `"./_generated/server"` | Public read operations (real-time subscriptions) |
| `mutation` | `"./_generated/server"` | Public write operations |
| `action` | `"./_generated/server"` | Public external API calls |
| `internalQuery` | `"./_generated/server"` | Internal read (for HTTP actions, scheduled jobs) |
| `internalMutation` | `"./_generated/server"` | Internal write (for HTTP actions, scheduled jobs) |
| `internalAction` | `"./_generated/server"` | Internal external API calls |
| `httpAction` | `"./_generated/server"` | Raw HTTP endpoint handler |

## Best Practices

### 1. Always Use Indexes

```ts
// Good - uses index
const records = await ctx.db
  .query("glucoseRecords")
  .withIndex("by_patient_date", (q) => q.eq("patientId", patientId))
  .order("desc")
  .take(10);

// Bad - full table scan
const records = await ctx.db
  .query("glucoseRecords")
  .filter((q) => q.eq(q.field("patientId"), patientId))
  .collect();
```

### 2. Parallel Fetches

```ts
// Good - parallel
const [glucose, sleep, insulin] = await Promise.all([
  ctx.db.query("glucoseRecords").withIndex(...).collect(),
  ctx.db.query("sleepRecords").withIndex(...).collect(),
  ctx.db.query("insulinDoseRecords").withIndex(...).collect(),
]);

// Bad - sequential
const glucose = await ctx.db.query("glucoseRecords").withIndex(...).collect();
const sleep = await ctx.db.query("sleepRecords").withIndex(...).collect();
const insulin = await ctx.db.query("insulinDoseRecords").withIndex(...).collect();
```

### 3. Return Minimal Data

```ts
// Good - return only what's needed
return {
  id: record._id,
  value: record.value,
  date: record.date,
};

// Avoid - returning full documents when not needed
return record;
```

### 4. Error Messages in Spanish

Since this is a patient-facing app in Spanish, error messages should be in Spanish:

```ts
throw new Error("Paciente no encontrado");
throw new Error("No hay registros de glucosa para actualizar");
```

### 5. Timestamps

- Use `Date.now()` for timestamps
- Store dates as `"YYYY-MM-DD"` strings when only the date matters
- Use `recordedAt` / `administeredAt` / `createdAt` for precise timestamps
